Package-o-tron is a collection of utilities to help managing cabal
files for your projects, maintaining Makefiles and other build
systems, and also some which help with your package database.


The central code is a function which takes a list of source root
folders and a list of sources (e.g. the exposed modules of a library
and/or the exes), then it parses and recursively finds all the locally
imported files, producing a list of the filenames, module names, the
imports from each file and for each import, the filenames of the local
source files matching it, and the names of the matching installed
packages with that module.

MakeHaskellMake

The Makefile in the package-o-tron package gives an example of how to
use package-o-tron to help manage a makefile for haskell projects,
using the MakeHaskellMake command.

You could use a Makefile:

* to quickly develop when you have multiple .cabal projects and don't
  want to spend time reinstalling them when you do a rebuild (this can
  also be much faster if you use -j and have lots of executables)

* if you have files to compile as part of the development which aren't
  in a cabal package, or if you want to integrate with existing
  Makefiles, e.g. for mixed haskell/c projects.

See the Makefile and autorules.mk in the repo (link below) for an
example of how this works. This tool is used in the hssqlppp project
Makefile (https://github.com/JakeWheat/hssqlppp), see the Makefile and
autorules.mk there for another example.


CabalLint

CabalLint will check the following issues in your cabal file:

* missing and superfluous other-modules and build-deps in library,exe
  and test sections

* version ranges which exclude the latest versions of a build-dep
  (just uses packdeps from hackage)

* a few more minor features planned

run it like this:
CabalLint package-o-tron.cabal
No output means everything OK


SavePackages

Run on a set of sources, and it will show you all the packages
referenced by these sources and their local dependencies, and all the
packages which those packages depend on.

If you pass an output folder, it will attempt to copy a complete set
of package tarballs to that folder which allow a fresh install on a
machine without needed to download anything, and getting the exact
same versions of all the packages. It does this by filtering out the
packages which come with ghc, and looking for the tarballs of the
remaining packages in your $HOME/.cabal folder.

This can be used to create a 'blessed' set of packages and versions
which you can test and deterministically reinstall on a fresh system
or sandbox.


Planned utils:

Cabal build testing

Use sandboxing to check the sdists from a .cabal install without error
and if there are tests they run and pass. The sandboxing is used to
check a range of versions of ghc crossed with the lowest and latest
versions of the dependencies listed in the .cabal. Later, maybe this
can be extended to search earlier versions of dependencies to get more
accurate lower bounds.

Package database lint:

check your ghc package database for the following issues:
duplicate packages installed
packages which aren't the latest versions installed
not sure how to automatically help with these situations though

Third party cabal install checker:

run a wrapper around cabal-install ... --dry-run. reports:
any reinstalls (easy since cabal already does this)
any different versions of already installed packages would be
  installed
any versions of packages which aren't the latest of those packages
  would be installed

Third party cabal file hacker:

when you try to install a lot of packages, and some of them have
version constraints on their dependencies which lead to another
package being installed not at the latest version: this will cabal
unpack the offending packages and alter their constraints to allow all
the latest versions of packages automatically. Not completely safe of
course, but I always end up doing this manually and it is really
tedious.



Repository: https://github.com/JakeWheat/package-o-tron

Contact: jakewheatmail@gmail.com
